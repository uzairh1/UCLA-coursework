1a.   

           50
        /     \
      20      60
     / \       \
    10  40     70
     \   /    /  \
      15 30  67   80
         / \      / 
        24  38   75                

1b.

inorder: 10 15 20 24 30 38 40 50 60 67 70 75 80
preorder: 50 20 10 15 40 30 24 38 60 70 67 80 75
postorder: 15 10 24 38 30 40 20 67 75 80 70 60 50

1c. 


           50
        /     \
      40      60
     / \       \
    10  38     70
     \   /    /  \
      15 24  67  80
                / 
               75
2a.

struct Node
{
  Node* leftChild;
  Node* rightChild;
  Node* parent;
  int data;
}

2b.

Node* insert(Node* subtree, Node* newNode)
{
   if (subtree is nullptr)
	return newNode
   else if (subtree's data is greater than newNode's data)
	recursively call insert on subtree's left child and newNode
	set subtree's left child to be the result from the recursive call
        set the recursive call's result's parent to subtree
   else
       recursively call insert on subtree's right child and newNode
       set subtree's right child to be the result from the recursive call
       set the recursive call's result's parent to subtree

return subtree

}

3a.


           7
        /     \
      5        6
     / \       /
    4  3       1 



3b. [7, 5, 6, 4, 3, 1]

3c. [6, 5, 1, 4, 3]

4.

a. O(C + S)
b. O(log C + S)
c. O(log C + log S)
d. O(log S)
e. O(1)
f. O(log C + S)
g. O(S log S)
h. O(C log S)