# Week 1, Lecture 1
# Overview
Building software that works
Why do we care if it works? We want to change the world via software...
> Landscape Scheduler for UCLA administration
#### What to know:
- How it's done now
- Who's available and when
- What equipment must be used
- Map of grounds
# Goals
- File systems (and databases)
- Scripting (speed of development > other aspects like runtime speed or correctness)
	- Shell (sh)
	- Python
	- Lisp
- Building, configuring (big issues arise here if done improperly), distributing
- Version control (Git [internals])
- Low-level programming (C language) / debugging (GDB)
- Web-based client-server applications (distributed applications; programs that run across the Internet; collection of computers that can be thought of as the application you want)
# Non-goals
- Algorithms, data structures, OOP
- Large language model prompting
- Agent-driven development using model context protocols (MCPs)
- Software engineering in general (take CS 130 instead)
### Emacs (Editing MACroS)
- One of the simpler IDEs (it's more study-able)
- Source code is not terribly complex and is readily understandable
# Week 1, Lecture 2
# Week 2, Lecture 1
# Week 2, Lecture 2
# Week 3, Lecture 1
# Week 3, Lecture 2
# Week 4, Lecture 1
# Week 4, Lecture 2
# Week 5, Lecture 1
# Week 5, Lecture 2
# Week 6, Lecture 1
# Week 6, Lecture 2
# Week 7, Lecture 1
# Week 7, Lecture 2
# Week 8, Lecture 1
# Week 8, Lecture 2
# Week 9, Lecture 1
# Week 9, Lecture 2
# Week 10, Lecture 1
# Week 10, Lecture 2

